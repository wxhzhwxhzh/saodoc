---
id: intro4
permalink: /js/arrow
title: '🔵 箭头函数'
---
# JavaScript 箭头函数详解

## 什么是箭头函数

箭头函数是 ES6 (ECMAScript 2015) 引入的一种更简洁的函数表达式语法。它使用 `=>` 符号定义函数,因此得名"箭头函数"。

## 基本语法

箭头函数有多种写法,取决于参数数量和函数体的复杂程度:

### 1. 基础形式

```javascript
// 传统函数表达式
const add = function(a, b) {
  return a + b;
};

// 箭头函数
const add = (a, b) => {
  return a + b;
};
```

### 2. 单个参数可省略括号

```javascript
// 有括号
const square = (x) => {
  return x * x;
};

// 省略括号
const square = x => {
  return x * x;
};
```

### 3. 单行表达式可省略 return 和花括号

```javascript
// 完整写法
const square = x => {
  return x * x;
};

// 简化写法(隐式返回)
const square = x => x * x;

const add = (a, b) => a + b;
```

### 4. 无参数需要空括号

```javascript
const sayHello = () => {
  console.log('Hello!');
};

// 简化版
const sayHello = () => 'Hello!';
```

### 5. 返回对象字面量需要加括号

```javascript
// 错误:会被当作函数体的花括号
const makePerson = (name, age) => { name: name, age: age };

// 正确:用括号包裹对象
const makePerson = (name, age) => ({ name: name, age: age });

// 使用属性简写
const makePerson = (name, age) => ({ name, age });
```

## 箭头函数与传统函数的区别

### 1. this 绑定

这是箭头函数最重要的特性:箭头函数不绑定自己的 `this`,而是继承外层作用域的 `this`。

```javascript
// 传统函数示例
function Person() {
  this.age = 0;
  
  setInterval(function() {
    this.age++; // this 指向 window/global,不是 Person
    console.log(this.age); // NaN
  }, 1000);
}

// 箭头函数示例
function Person() {
  this.age = 0;
  
  setInterval(() => {
    this.age++; // this 继承自 Person
    console.log(this.age); // 1, 2, 3...
  }, 1000);
}
```

**实际应用场景:**

```javascript
class Counter {
  constructor() {
    this.count = 0;
  }
  
  // 传统方法需要 bind
  incrementTraditional() {
    setTimeout(function() {
      this.count++;
      console.log(this.count);
    }.bind(this), 1000);
  }
  
  // 箭头函数自动绑定
  incrementArrow() {
    setTimeout(() => {
      this.count++;
      console.log(this.count);
    }, 1000);
  }
}
```

### 2. 不能作为构造函数

箭头函数不能使用 `new` 关键字调用。

```javascript
// 传统函数可以
function Person(name) {
  this.name = name;
}
const person = new Person('张三'); // ✓ 正常工作

// 箭头函数不行
const Person = (name) => {
  this.name = name;
};
const person = new Person('张三'); // ✗ 报错:Person is not a constructor
```

### 3. 没有 arguments 对象

箭头函数内部没有 `arguments` 对象,但可以使用剩余参数。

```javascript
// 传统函数
function sum() {
  return Array.from(arguments).reduce((a, b) => a + b, 0);
}
console.log(sum(1, 2, 3)); // 6

// 箭头函数(使用剩余参数)
const sum = (...args) => {
  return args.reduce((a, b) => a + b, 0);
};
console.log(sum(1, 2, 3)); // 6
```

### 4. 不能使用 yield

箭头函数不能用作 Generator 函数。

## 实际应用场景

### 1. 数组方法

箭头函数在数组方法中特别简洁:

```javascript
const numbers = [1, 2, 3, 4, 5];

// map
const doubled = numbers.map(n => n * 2);
console.log(doubled); // [2, 4, 6, 8, 10]

// filter
const evens = numbers.filter(n => n % 2 === 0);
console.log(evens); // [2, 4]

// reduce
const sum = numbers.reduce((acc, n) => acc + n, 0);
console.log(sum); // 15

// 链式调用
const result = numbers
  .filter(n => n > 2)
  .map(n => n * 2)
  .reduce((acc, n) => acc + n, 0);
console.log(result); // 24
```

### 2. Promise 和异步操作

```javascript
// 传统写法
fetch('https://api.example.com/data')
  .then(function(response) {
    return response.json();
  })
  .then(function(data) {
    console.log(data);
  });

// 箭头函数写法
fetch('https://api.example.com/data')
  .then(response => response.json())
  .then(data => console.log(data));
```

### 3. 事件处理(注意 this)

```javascript
// ✗ 不推荐:箭头函数无法访问 DOM 元素
button.addEventListener('click', () => {
  console.log(this); // window,不是 button
});

// ✓ 推荐:使用传统函数
button.addEventListener('click', function() {
  console.log(this); // button 元素
});

// ✓ 或者使用事件参数
button.addEventListener('click', (e) => {
  console.log(e.target); // button 元素
});
```

### 4. 函数式编程

```javascript
// 柯里化
const multiply = x => y => x * y;
const double = multiply(2);
console.log(double(5)); // 10

// 组合函数
const compose = (...fns) => x => 
  fns.reduceRight((acc, fn) => fn(acc), x);

const addOne = x => x + 1;
const square = x => x * x;
const composed = compose(square, addOne);
console.log(composed(5)); // 36 (先 5+1=6,再 6*6=36)
```

## 最佳实践

### 何时使用箭头函数

✓ **推荐使用:**
- 数组方法的回调函数
- Promise 的 then/catch
- 需要保持外层 this 的场景
- 简短的函数表达式

```javascript
const users = [
  { name: '张三', age: 25 },
  { name: '李四', age: 30 }
];

// 清晰简洁
const names = users.map(user => user.name);
const adults = users.filter(user => user.age >= 18);
```

✗ **不推荐使用:**
- 需要动态 this 的方法
- 需要使用 arguments 对象
- 需要作为构造函数

```javascript
const obj = {
  count: 0,
  // ✗ 不推荐:箭头函数的 this 不指向 obj
  incrementWrong: () => {
    this.count++;
  },
  // ✓ 推荐:使用普通方法
  incrementRight() {
    this.count++;
  }
};
```

## 总结

箭头函数提供了更简洁的语法,主要优势是词法作用域的 `this` 绑定。理解箭头函数与传统函数的区别,能帮助你在适当的场景选择正确的函数类型,写出更清晰、更易维护的代码。