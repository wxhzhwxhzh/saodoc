---
id: intro3
permalink: /js/promise
title: '🔵 Promise'
---

# JavaScript Promise 详解

> 完整、实用、带示例的 JavaScript Promise（承诺/期约）中文指南。

## 目录

- [JavaScript Promise 详解](#javascript-promise-详解)
  - [目录](#目录)
  - [简介](#简介)
  - [Promise 的三种状态](#promise-的三种状态)
  - [Promise 的构造与用法](#promise-的构造与用法)
    - [构造器签名](#构造器签名)
    - [resolve / reject 的行为](#resolve--reject-的行为)
  - [实例方法：`then` / `catch` / `finally`](#实例方法then--catch--finally)
    - [`then(onFulfilled, onRejected)`](#thenonfulfilled-onrejected)
    - [`catch(onRejected)`](#catchonrejected)
    - [`finally(onFinally)`](#finallyonfinally)
  - [静态方法：`Promise.resolve` / `reject` / `all` / `allSettled` / `race` / `any`](#静态方法promiseresolve--reject--all--allsettled--race--any)
  - [异步队列：微任务（microtask）与宏任务（macrotask）](#异步队列微任务microtask与宏任务macrotask)
  - [Promise 链（chaining）与错误传播](#promise-链chaining与错误传播)
  - [`async` / `await` 与 Promise 的互操作](#async--await-与-promise-的互操作)
  - [常见模式与示例](#常见模式与示例)
    - [并行（Parallel）与顺序（Sequential）执行](#并行parallel与顺序sequential执行)
    - [超时包装（timeout）](#超时包装timeout)
    - [重试（retry）](#重试retry)
    - [将回调函数封装为 Promise（promisify）](#将回调函数封装为-promisepromisify)
  - [常见坑、反模式与调试技巧](#常见坑反模式与调试技巧)
  - [简化版 Promise 实现（教学用）](#简化版-promise-实现教学用)
  - [总结与建议](#总结与建议)
  - [附录：参考与兼容性说明](#附录参考与兼容性说明)

---

## 简介

`Promise` 是 ECMAScript 中用于表示**异步操作**最终完成（或失败）及其结果值的对象。它解决了回调地狱（callback hell）和异步错误传播难以管理的问题，使得异步流程更像同步代码链式表达。现代 JS（尤其与 `async/await`）中，Promise 是异步编程的基础。

---

## Promise 的三种状态

* **pending（进行中）**：初始状态，既不是成功也不是失败。
* **fulfilled（已兑现 / 成功）**：异步操作成功完成，有一个结果值（value）。
* **rejected（已拒绝 / 失败）**：操作失败，有一个拒因（reason）。

状态从 `pending` 只能转到 `fulfilled` 或 `rejected`，且一旦改变就不可再更改。

---

## Promise 的构造与用法

### 构造器签名

```js
new Promise((resolve, reject) => {
  // 执行异步操作
  // 成功时调用 resolve(value)
  // 失败或异常时调用 reject(error)
});
```

**参数**：构造函数接收一个 `executor` 函数，`executor` 会立即执行，并接收两个参数：`resolve` 和 `reject`。

**返回值**：一个 `Promise` 实例。

### resolve / reject 的行为

* `resolve(value)`：将 Promise 标记为已兑现（fulfilled），并将 `value` 作为结果；如果 `value` 是另一个 Promise（或 thenable），则会“采用”该 thenable 的状态（遵循 Promise resolution procedure）。
* `reject(reason)`：将 Promise 标记为已拒绝（rejected），并将 `reason` 作为拒因。

**示例**：

```js
const p = new Promise((resolve, reject) => {
  setTimeout(() => resolve('done'), 1000);
});

p.then(value => console.log(value)); // 1 秒后输出 'done'
```

---

## 实例方法：`then` / `catch` / `finally`

### `then(onFulfilled, onRejected)`

* 返回值：一个新的 Promise（允许链式调用）。
* 参数：

  * `onFulfilled`：当原始 Promise 成功时调用，接收 value。
  * `onRejected`：当原始 Promise 失败时调用，接收 reason。

重要行为：

* `then` 的回调如果返回值 `x`：

  * 如果 `x` 是普通值，新返回的 Promise 会以该值 fulfill。
  * 如果 `x` 是 Promise/thenable，则新 Promise 会“跟随”它的状态。
  * 如果回调抛出异常，则新 Promise 会 reject。

示例：

```js
Promise.resolve(1)
  .then(x => x + 1)           // 返回 2
  .then(x => new Promise(res => setTimeout(() => res(x * 3), 100)))
  .then(console.log)          // 输出 6
  .catch(err => console.error(err));
```

### `catch(onRejected)`

相当于 `.then(undefined, onRejected)`，用于捕获链中的错误。

```js
Promise.reject(new Error('fail'))
  .catch(err => console.error('caught', err.message));
```

### `finally(onFinally)`

`finally` 不会接收结果值或拒因（回调中也不能改变最终的值），用于做资源清理逻辑。`finally` 返回一个 Promise；如果 `onFinally` 返回 Promise，会等待它完成后再继续传递原始值或拒因。

```js
fetch(url)
  .then(r => r.json())
  .catch(e => console.error(e))
  .finally(() => console.log('done (clean up)'));
```

---

## 静态方法：`Promise.resolve` / `reject` / `all` / `allSettled` / `race` / `any`

| 方法                             | 行为                                                                       |
| ------------------------------ | ------------------------------------------------------------------------ |
| `Promise.resolve(value)`       | 生成一个已兑现的 Promise；若 `value` 为 thenable，则会“采用”它的状态。                        |
| `Promise.reject(reason)`       | 生成一个已拒绝的 Promise。                                                        |
| `Promise.all(iterable)`        | 等待所有 Promise 都 fulfill，或任一 reject（立即 reject）。返回一个按输入顺序的值数组。              |
| `Promise.allSettled(iterable)` | 等待所有 Promise 完成（无论 fulfill/reject），返回每个的状态与值/原因对象数组。                     |
| `Promise.race(iterable)`       | 只要第一个 Promise settle（fulfilled 或 rejected），就以它的结果 settle。                |
| `Promise.any(iterable)`        | 返回第一个 fulfilled 的 Promise；如果全部都 rejected，则返回一个 `AggregateError`（ES2021）。 |

示例：

```js
const a = Promise.resolve(1);
const b = new Promise(res => setTimeout(() => res(2), 100));
const c = Promise.resolve(3);

Promise.all([a, b, c]).then(console.log); // [1, 2, 3]

Promise.allSettled([a, Promise.reject('err')]).then(console.log);

Promise.race([
  new Promise(res => setTimeout(() => res('slow'), 200)),
  new Promise(res => setTimeout(() => res('fast'), 50))
]).then(console.log); // 'fast'

Promise.any([Promise.reject('x'), Promise.resolve(42)]).then(console.log); // 42
```

兼容性注：`Promise.any` 在较新 ECMAScript 标准中（ES2021）引入，老环境需要 polyfill。

---

## 异步队列：微任务（microtask）与宏任务（macrotask）

`Promise` 的 `then`/`catch` 回调会排入 **微任务队列（microtask）**，这意味着它们会在当前执行栈清空后立即运行，但在任何宏任务（如 `setTimeout` 回调）之前。

示例：

```js
console.log('script start');

setTimeout(() => console.log('setTimeout'), 0);

Promise.resolve().then(() => console.log('promise1')).then(() => console.log('promise2'));

console.log('script end');

// 输出顺序：
// script start
// script end
// promise1
// promise2
// setTimeout
```

理解微任务与宏任务对调试与性能非常重要，尤其在你依赖事件调用顺序时。

---

## Promise 链（chaining）与错误传播

* Promise 链是通过 `then` 返回新 Promise 来实现的。
* 错误会沿链向下传播，直到遇到第一个 `catch`（或 `then` 的第二个参数）。
* 若在 `.then` 中**忘记返回**一个内部 Promise，会导致链无法等待该异步操作完成。

示例：

```js
// 错误示范：没有 return
doSomething()
  .then(() => { fetch(url); }) // 没有 return，外部链不会等待 fetch 完成
  .then(() => console.log('after fetch?'));

// 正确：
doSomething()
  .then(() => fetch(url))
  .then(res => res.json())
  .then(data => console.log(data));
```

---

## `async` / `await` 与 Promise 的互操作

`async` 函数会隐式返回一个 Promise，`await` 会暂停 `async` 函数的执行直到等待的表达式 resolve（或抛出异常，转为 reject）。

```js
async function getJson(url) {
  const res = await fetch(url);
  if (!res.ok) throw new Error('HTTP Error');
  return res.json();
}

getJson('/api/data')
  .then(data => console.log(data))
  .catch(err => console.error(err));
```

**并行**：如果需要并行发多个请求，应先创建 Promise 再 `await Promise.all(...)`，不要在循环中直接 `await`（会顺序执行）：

```js
// 并行
const promises = urls.map(u => fetch(u).then(r => r.json()));
const results = await Promise.all(promises);

// 错误的顺序写法（会串行）
for (const u of urls) {
  const r = await fetch(u); // 等待一个完成才开始下一个
}
```

---

## 常见模式与示例

### 并行（Parallel）与顺序（Sequential）执行

并行（当任务相互独立）：使用 `Promise.all` 或并行创建多个 Promise 然后 `await Promise.all(...)`。

顺序（例如依赖上一步的结果）：使用 `for` + `await` 或通过 `Array.reduce` 串联 Promise。

顺序示例（使用 reduce）：

```js
const tasks = [
  () => Promise.resolve(1),
  () => new Promise(res => setTimeout(() => res(2), 100)),
  () => Promise.resolve(3)
];

tasks.reduce((p, task) =>
  p.then(results => task().then(r => results.concat(r))),
  Promise.resolve([])
).then(results => console.log(results)); // [1, 2, 3]
```

### 超时包装（timeout）

```js
function withTimeout(promise, ms) {
  const timeout = new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout')), ms));
  return Promise.race([promise, timeout]);
}

// 使用：
withTimeout(fetch('/big'), 5000)
  .then(...)
  .catch(err => console.error(err));
```

### 重试（retry）

```js
async function retry(fn, retries = 3, delay = 1000) {
  for (let i = 0; i < retries; i++) {
    try {
      return await fn();
    } catch (err) {
      if (i === retries - 1) throw err;
      await new Promise(res => setTimeout(res, delay));
    }
  }
}
```

### 将回调函数封装为 Promise（promisify）

```js
function readFilePromise(path) {
  return new Promise((resolve, reject) => {
    fs.readFile(path, 'utf8', (err, data) => {
      if (err) reject(err);
      else resolve(data);
    });
  });
}
```

---

## 常见坑、反模式与调试技巧

* **忘记 return**：在 `.then` 中没返回值会导致外层链不会等待内部异步。
* **Promise 构造器反模式**：不要用 `new Promise` 包装已经返回 Promise 的 API。例：`new Promise(resolve => fetch(...).then(resolve))` 是多此一举。
* **吞掉错误**：在 `.then` 中捕获错误但不重新抛出会导致外层不知异常发生。
* **未处理的拒绝（unhandled rejection）**：在 Node 或浏览器中应监听 `unhandledRejection`/`unhandledrejection`，生产环境至少记录日志。

调试技巧：

* 在 Node 中：

```js
process.on('unhandledRejection', (reason, promise) => {
  console.error('Unhandled Rejection at:', promise, 'reason:', reason);
});
```

* 在浏览器中：

```js
window.addEventListener('unhandledrejection', event => {
  console.error('Unhandled promise rejection:', event.reason);
});
```

---

## 简化版 Promise 实现（教学用）

> 下面实现用于帮助理解基本机制，但**并不完整**（不完全遵循 Promises/A+ 规范，亦未处理微任务队列等细节）。

```js
// 简化版 Promise（教学用）
function SimplePromise(executor) {
  this._state = 'pending';
  this._value = undefined;
  this._handlers = [];

  const resolve = (value) => {
    if (this._state !== 'pending') return;
    // 若 value 是 thenable，应进一步处理（省略）
    this._state = 'fulfilled';
    this._value = value;
    this._handlers.forEach(h => h.onFulfilled(value));
  };

  const reject = (reason) => {
    if (this._state !== 'pending') return;
    this._state = 'rejected';
    this._value = reason;
    this._handlers.forEach(h => h.onRejected(reason));
  };

  try {
    executor(resolve, reject);
  } catch (e) {
    reject(e);
  }
}

SimplePromise.prototype.then = function(onFulfilled, onRejected) {
  return new SimplePromise((resolve, reject) => {
    const handle = {
      onFulfilled: (value) => {
        if (!onFulfilled) return resolve(value);
        try {
          resolve(onFulfilled(value));
        } catch (e) {
          reject(e);
        }
      },
      onRejected: (reason) => {
        if (!onRejected) return reject(reason);
        try {
          resolve(onRejected(reason));
        } catch (e) {
          reject(e);
        }
      }
    };

    if (this._state === 'pending') this._handlers.push(handle);
    else if (this._state === 'fulfilled') handle.onFulfilled(this._value);
    else handle.onRejected(this._value);
  });
};
```

> 说明：真实的 Promise 实现需要处理 thenable 的递归解析（Promise Resolution Procedure）并保证回调在微任务中异步执行等细节。

---

## 总结与建议

* `Promise` 是现代 JavaScript 异步编程的基石。配合 `async/await`，能写出既简洁可读又强大的异步逻辑。
* 习惯在链末处理错误（`catch`）或在 `async` 中使用 `try/catch`。
* 注意微任务/宏任务行为，尤其在需要严格执行顺序时。
* 避免常见反模式：重复包装 Promise、不返回内部 Promise、吞掉错误。

---

## 附录：参考与兼容性说明

* `Promise` 标准在 ES2015（ES6）引入；`Promise.any` 在 ES2021 引入。
* 在旧环境（IE）需要 polyfill（例如使用 core-js 或 es6-promise）。

如果你需要，我可以：

* 将此 Markdown 导出为 `.md` 文件供下载，或
* 按需生成配套的演示代码（可运行的 Node/浏览器示例），或
* 把示例改成中文注释的 runnable snippet。

---

*— 结束 —*
