---
id: intro2
permalink: /js/hook
title: '🔵 函数Hook'
---

## 1. 函数Hook（拦截函数调用）
- 在JavaScript逆向过程中，常见的Hook技术主要用于拦截、监控和修改函数调用、属性访问、网络请求等行为。以下是几种常用的Hook代码：

### 基础函数Hook
```javascript
// Hook单个函数
const originalFunction = targetObject.targetFunction;
targetObject.targetFunction = function(...args) {
    console.log('函数调用:', args);
    
    // 在函数执行前的操作
    const result = originalFunction.apply(this, args);
    
    // 在函数执行后的操作
    console.log('函数返回:', result);
    return result;
};
```

### 通用函数Hook工具
```javascript
function hookFunction(obj, funcName, beforeCallback, afterCallback) {
    const originalFunc = obj[funcName];
    obj[funcName] = function(...args) {
        if (beforeCallback) {
            beforeCallback.call(this, args);
        }
        const result = originalFunc.apply(this, args);
        if (afterCallback) {
            afterCallback.call(this, args, result);
        }
        return result;
    };
}

// 使用示例
hookFunction(console, 'log', (args) => {
    console.log('即将输出:', args);
}, (args, result) => {
    console.log('已输出:', args);
});
```

## 2. 属性Hook（Proxy拦截）

### 使用Proxy拦截对象属性
```javascript
// Hook整个对象
function hookObject(obj) {
    return new Proxy(obj, {
        get(target, prop, receiver) {
            console.log(`访问属性: ${prop.toString()}`);
            return Reflect.get(target, prop, receiver);
        },
        set(target, prop, value, receiver) {
            console.log(`设置属性: ${prop.toString()} = ${value}`);
            return Reflect.set(target, prop, value, receiver);
        },
        apply(target, thisArg, args) {
            console.log(`函数调用: ${target.name}`, args);
            return Reflect.apply(target, thisArg, args);
        }
    });
}

// 使用示例
const hookedWindow = hookObject(window);
```

### Hook特定属性（如localStorage）
```javascript
// Hook localStorage
const originalSetItem = localStorage.setItem;
localStorage.setItem = function(key, value) {
    console.log(`localStorage设置: ${key} = ${value}`);
    return originalSetItem.call(this, key, value);
};

const originalGetItem = localStorage.getItem;
localStorage.getItem = function(key) {
    const value = originalGetItem.call(this, key);
    console.log(`localStorage获取: ${key} = ${value}`);
    return value;
};
```

## 3. 网络请求Hook

### XMLHttpRequest Hook
```javascript
// Hook XMLHttpRequest
const originalOpen = XMLHttpRequest.prototype.open;
const originalSend = XMLHttpRequest.prototype.send;

XMLHttpRequest.prototype.open = function(method, url, ...args) {
    this._url = url;
    this._method = method;
    return originalOpen.call(this, method, url, ...args);
};

XMLHttpRequest.prototype.send = function(body) {
    console.log('XHR请求:', {
        method: this._method,
        url: this._url,
        body: body
    });
    
    // 监听响应
    this.addEventListener('load', function() {
        console.log('XHR响应:', {
            url: this._url,
            status: this.status,
            response: this.responseText
        });
    });
    
    return originalSend.call(this, body);
};
```

### Fetch API Hook
```javascript
// Hook fetch
const originalFetch = window.fetch;
window.fetch = function(...args) {
    const [url, options = {}] = args;
    console.log('Fetch请求:', { url, options });
    
    return originalFetch.apply(this, args).then(response => {
        const clonedResponse = response.clone();
        clonedResponse.text().then(text => {
            console.log('Fetch响应:', { url, response: text });
        });
        return response;
    });
};
```

## 4. 调试器检测绕过Hook

### 绕过debugger检测
```javascript
// 禁用debugger语句
window.addEventListener('load', function() {
    // 方法1: 重写debugger
    const originalEval = eval;
    window.eval = function(code) {
        if (code === 'debugger') return;
        return originalEval(code);
    };
    
    // 方法2: 使用Proxy拦截
    const script = document.createElement('script');
    const originalAppendChild = document.head.appendChild;
    document.head.appendChild = function(node) {
        if (node instanceof HTMLScriptElement) {
            node.textContent = node.textContent.replace(/debugger;/g, '');
        }
        return originalAppendChild.call(this, node);
    };
});
```

### 绕过console检测
```javascript
// Hook console防止检测
const originalLog = console.log;
console.log = function(...args) {
    // 可以选择性地屏蔽某些日志
    if (!args.some(arg => typeof arg === 'string' && arg.includes('debug'))) {
        originalLog.apply(console, args);
    }
};
```

## 5. 加密函数Hook

### Hook常见的加密库
```javascript
// Hook CryptoJS
if (window.CryptoJS) {
    const originalAES = CryptoJS.AES.encrypt;
    CryptoJS.AES.encrypt = function(message, key, cfg) {
        console.log('AES加密:', { message, key, cfg });
        const result = originalAES.call(this, message, key, cfg);
        console.log('AES结果:', result.toString());
        return result;
    };
}

// Hook Web Crypto API
if (window.crypto && window.crypto.subtle) {
    const originalEncrypt = crypto.subtle.encrypt;
    crypto.subtle.encrypt = function(algorithm, key, data) {
        console.log('Web Crypto加密:', { algorithm, key, data });
        return originalEncrypt.call(this, algorithm, key, data);
    };
}
```

## 6. 时间函数Hook

### Hook Date和定时器
```javascript
// Hook Date构造函数
const originalDate = Date;
window.Date = function(...args) {
    if (args.length === 0) {
        console.log('获取当前时间');
    }
    return new originalDate(...args);
};
Date.prototype = originalDate.prototype;

// Hook setTimeout/setInterval
const originalSetTimeout = setTimeout;
window.setTimeout = function(callback, delay, ...args) {
    console.log('设置定时器:', { callback, delay, args });
    return originalSetTimeout.call(this, callback, delay, ...args);
};
```

## 7. DOM操作Hook

### Hook DOM方法
```javascript
// Hook createElement
const originalCreateElement = document.createElement;
document.createElement = function(tagName, options) {
    console.log('创建元素:', tagName);
    const element = originalCreateElement.call(this, tagName, options);
    return element;
};

// Hook appendChild
const originalAppendChild = Element.prototype.appendChild;
Element.prototype.appendChild = function(child) {
    console.log('添加子元素:', child);
    return originalAppendChild.call(this, child);
};
```

## 8. 通用Hook框架

### 完整的Hook工具类
```javascript
class HookManager {
    static hookFunction(obj, funcName, options = {}) {
        const originalFunc = obj[funcName];
        if (!originalFunc) return;
        
        obj[funcName] = function(...args) {
            if (options.before) options.before.call(this, args);
            try {
                const result = originalFunc.apply(this, args);
                if (options.after) options.after.call(this, args, result);
                return result;
            } catch (error) {
                if (options.onError) options.onError.call(this, error, args);
                throw error;
            }
        };
    }
    
    static hookProperty(obj, propName, options = {}) {
        let value = obj[propName];
        
        Object.defineProperty(obj, propName, {
            get() {
                if (options.onGet) options.onGet(value);
                return value;
            },
            set(newValue) {
                if (options.onSet) options.onSet(newValue, value);
                value = newValue;
            },
            configurable: true,
            enumerable: true
        });
    }
    
    static hookAllMethods(obj, exclude = []) {
        Object.getOwnPropertyNames(obj).forEach(prop => {
            if (exclude.includes(prop)) return;
            if (typeof obj[prop] === 'function') {
                this.hookFunction(obj, prop, {
                    before: (args) => console.log(`${prop} called with:`, args)
                });
            }
        });
    }
}

// 使用示例
HookManager.hookFunction(window, 'alert', {
    before: (args) => console.log('Alert被调用:', args[0])
});

HookManager.hookProperty(navigator, 'userAgent', {
    onGet: (value) => console.log('读取userAgent:', value)
});
```

## 使用注意事项：

1. **执行时机**：Hook代码需要在目标函数/对象被使用之前执行
2. **作用域问题**：注意`this`指向和作用域链
3. **性能影响**：大量Hook可能影响页面性能
4. **反Hook检测**：有些网站会检测Hook行为，需要更隐蔽的实现方式
5. **兼容性**：确保Hook代码在目标环境中能够正常运行

